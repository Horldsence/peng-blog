/**
 * Liquid Glass Background Component
 *
 * A dynamic liquid glass refraction effect based on Three.js and SVG displacement maps.
 * This component creates a full-screen liquid glass effect with particle physics simulation.
 *
 * Features:
 * - Particle-based physics simulation with attraction/repulsion forces
 * - SVG feDisplacementMap for magnifying glass effect
 * - Canvas-generated displacement maps based on particle positions
 * - Mouse interaction (drag particles)
 * - No external dependencies (removed html2canvas)
 *
 * Performance Optimizations:
 * - Reduced particle count (10 particles instead of 15)
 * - Efficient canvas-based displacement map generation
 * - GPU-accelerated SVG filters
 */

import { useEffect, useRef } from 'react';

// Configuration
const CONFIG = {
  // Particle settings
  particleNum: 10,
  particleRenderRadius: 50,

  // Physics parameters
  dt: 0.5, // Time step
  targetDistance: 40, // Repulsion distance threshold
  attractionPeak: 100, // Attraction peak distance
  attractionEnd: 200, // Attraction zero distance
  forceScale1: 2, // Repulsion force scale
  forceScale2: 0.5, // Attraction force scale
  damping: 0.03, // Damping factor
  viscosityStrength: 0.03, // Viscosity strength
  viscosityEnd: 100, // Viscosity end distance
  boundaryMargin: 50, // Boundary margin

  // Drag interaction
  dragStrength: 0.2,
  dragViscosityFactor: 10,

  // Performance
  displacementInterval: 3, // Update displacement map every N frames

  // SVG displacement
  displacementScale: 50, // Strength of displacement effect
};

interface Particles {
  location: number[][];
  velocity: number[][];
}

export function LiquidGlassBackground() {
  const containerRef = useRef<HTMLDivElement>(null);
  const particlesRef = useRef<Particles | null>(null);
  const dragStateRef = useRef<any>(null);
  const animationRef = useRef<number | null>(null);
  const displacementCanvasRef = useRef<HTMLCanvasElement | null>(null);
  const svgFilterRef = useRef<SVGSVGElement | null>(null);

  useEffect(() => {
    if (!containerRef.current) return;

    const container = containerRef.current;
    let width = window.innerWidth;
    let height = window.innerHeight;

    container.style.width = `${width}px`;
    container.style.height = `${height}px`;

  useEffect(() => {
    if (!containerRef.current) return;

    const container = containerRef.current;
    let width = window.innerWidth;
    let height = window.innerHeight;

    container.style.width = `${width}px`;
    container.style.height = `${height}px`;

    // Create displacement map canvas
    const displacementCanvas = document.createElement('canvas');
    displacementCanvas.width = width;
    displacementCanvas.height = height;
    displacementCanvas.style.display = 'none';
    document.body.appendChild(displacementCanvas);
    displacementCanvasRef.current = displacementCanvas;

    const ctx = displacementCanvas.getContext('2d');
    if (!ctx) return;

    // Create displacement map canvas
    const displacementCanvas = document.createElement('canvas');
    displacementCanvas.width = width;
    displacementCanvas.height = height;
    displacementCanvas.style.display = 'none';
    document.body.appendChild(displacementCanvas);
    displacementCanvasRef.current = displacementCanvas;

    const ctx = displacementCanvas.getContext('2d');
    if (!ctx) return;

    // Initialize particles
    const initParticles = (): Particles => {
      const width = window.innerWidth;
      const height = window.innerHeight;

      return {
        location: Array.from({ length: CONFIG.particleNum }, () => [
          (0.5 + (Math.random() - 0.5) * 0.3) * width,
          (0.5 + (Math.random() - 0.5) * 0.3) * height,
        ]),
        velocity: Array.from({ length: CONFIG.particleNum }, () => [0, 0]),
      };
    };

    particlesRef.current = initParticles();
    dragStateRef.current = {
      active: false,
      particleIndex: undefined,
      offset: undefined,
      target: undefined,
    };

    // Physics simulation step
    const oneStep = () => {
      if (!particlesRef.current) return;
      const particles = particlesRef.current;
      const dragState = dragStateRef.current;

      const bodyWidth = window.innerWidth - CONFIG.boundaryMargin;
      const bodyHeight = window.innerHeight - CONFIG.boundaryMargin;

      // Apply damping
      for (let i = 0; i < CONFIG.particleNum; i++) {
        particles.velocity[i][0] *= 1 - CONFIG.damping * CONFIG.dt;
        particles.velocity[i][1] *= 1 - CONFIG.damping * CONFIG.dt;
      }

      // Particle interactions
      for (let i = 0; i < CONFIG.particleNum; i++) {
        const posA = particles.location[i];

        for (let j = i + 1; j < CONFIG.particleNum; j++) {
          const posB = particles.location[j];
          const dx = posB[0] - posA[0];
          const dy = posB[1] - posA[1];
          const dist = Math.sqrt(dx * dx + dy * dy);

          // Viscosity
          if (dist < CONFIG.viscosityEnd) {
            let strength = CONFIG.viscosityStrength * (1 - dist / CONFIG.viscosityEnd);
            if (dragState.active && (dragState.particleIndex === i || dragState.particleIndex === j)) {
              strength *= CONFIG.dragViscosityFactor;
            }
            const impactX = (particles.velocity[j][0] - particles.velocity[i][0]) * strength * CONFIG.dt;
            const impactY = (particles.velocity[j][1] - particles.velocity[i][1]) * strength * CONFIG.dt;
            particles.velocity[i][0] += impactX;
            particles.velocity[i][1] += impactY;
            particles.velocity[j][0] -= impactX;
            particles.velocity[j][1] -= impactY;
          }

          // Distance-based forces
          if (dist < CONFIG.targetDistance) {
            // Repulsion
            const force = CONFIG.forceScale1 * (CONFIG.targetDistance - dist) / dist;
            const impactX = -dx * force * CONFIG.dt;
            const impactY = -dy * force * CONFIG.dt;
            particles.velocity[i][0] += impactX;
            particles.velocity[i][1] += impactY;
            particles.velocity[j][0] -= impactX;
            particles.velocity[j][1] -= impactY;
          } else if (dist < CONFIG.attractionEnd) {
            // Attraction
            let force: number;
            if (dist < CONFIG.attractionPeak) {
              force = CONFIG.forceScale2 * (dist - CONFIG.targetDistance) / CONFIG.attractionPeak;
            } else {
              force = CONFIG.forceScale2 * (CONFIG.attractionEnd - dist) / (CONFIG.attractionEnd - CONFIG.attractionPeak);
            }
            const impactX = (dx * force / dist) * CONFIG.dt;
            const impactY = (dy * force / dist) * CONFIG.dt;
            particles.velocity[i][0] += impactX;
            particles.velocity[i][1] += impactY;
            particles.velocity[j][0] -= impactX;
            particles.velocity[j][1] -= impactY;
          }
        }
      }

      // Mouse drag
      if (dragState.active) {
        const dx = dragState.target[0] - particles.location[dragState.particleIndex][0];
        const dy = dragState.target[1] - particles.location[dragState.particleIndex][1];
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < CONFIG.particleRenderRadius * 2) {
          particles.velocity[dragState.particleIndex][0] *= 0.8;
          particles.velocity[dragState.particleIndex][1] *= 0.8;
        }

        particles.velocity[dragState.particleIndex][0] += dx * CONFIG.dragStrength;
        particles.velocity[dragState.particleIndex][1] += dy * CONFIG.dragStrength;
      }

      // Update positions and handle boundaries
      for (let i = 0; i < CONFIG.particleNum; i++) {
        const pos = particles.location[i];
        const vel = particles.velocity[i];

        pos[0] += vel[0] * CONFIG.dt;
        pos[1] += vel[1] * CONFIG.dt;

        // Boundary constraints (elastic collision)
        if (pos[0] < CONFIG.boundaryMargin) {
          pos[0] = CONFIG.boundaryMargin;
          vel[0] *= -0.5;
        } else if (pos[0] > bodyWidth) {
          pos[0] = bodyWidth;
          vel[0] *= -0.5;
        }

        if (pos[1] < CONFIG.boundaryMargin) {
          pos[1] = CONFIG.boundaryMargin;
          vel[1] *= -0.5;
        } else if (pos[1] > bodyHeight) {
          pos[1] = bodyHeight;
          vel[1] *= -0.5;
        }
      }
    };

    // Create SVG filter
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', '0');
    svg.setAttribute('height', '0');
    svg.style.position = 'fixed';
    svg.style.top = '0';
    svg.style.left = '0';
    svg.style.pointerEvents = 'none';
    svg.style.zIndex = '9998';

    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    const filter = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
    const filterId = `liquid-glass-filter-${Date.now()}`;
    filter.setAttribute('id', filterId);
    filter.setAttribute('filterUnits', 'userSpaceOnUse');
    filter.setAttribute('x', '0');
    filter.setAttribute('y', '0');
    filter.setAttribute('width', width.toString());
    filter.setAttribute('height', height.toString());

    const feImage = document.createElementNS('http://www.w3.org/2000/svg', 'feImage');
    feImage.setAttribute('id', `${filterId}-map`);
    feImage.setAttribute('width', width.toString());
    feImage.setAttribute('height', height.toString());

    const feDisplacementMap = document.createElementNS('http://www.w3.org/2000/svg', 'feDisplacementMap');
    feDisplacementMap.setAttribute('in', 'SourceGraphic');
    feDisplacementMap.setAttribute('in2', `${filterId}-map`);
    feDisplacementMap.setAttribute('xChannelSelector', 'R');
    feDisplacementMap.setAttribute('yChannelSelector', 'G');
    feDisplacementMap.setAttribute('scale', CONFIG.displacementScale.toString());

    filter.appendChild(feImage);
    filter.appendChild(feDisplacementMap);
    defs.appendChild(filter);
    svg.appendChild(defs);
    document.body.appendChild(svg);
    svgFilterRef.current = svg;

    // Apply SVG filter via CSS
    container.style.backdropFilter = `url(#${filterId})`;

    // Generate displacement map based on particle positions
    const updateDisplacementMap = () => {
      if (!particlesRef.current || !ctx) return;
      const particles = particlesRef.current;

      const imageData = ctx.createImageData(width, height);
      const data = imageData.data;

      // Gaussian function for metaball effect
      const gaussian = (dx: number, dy: number, sigma: number) => {
        return Math.exp(-(dx * dx + dy * dy) / (2 * sigma * sigma));
      };

      // Calculate displacement for each pixel
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const idx = (y * width + x) * 4;

          let sumWeights = 0;
          let weightedDx = 0;
          let weightedDy = 0;

          // Accumulate contributions from all particles
          for (let i = 0; i < CONFIG.particleNum; i++) {
            const px = particles.location[i][0];
            const py = height - particles.location[i][1]; // Flip Y for screen coordinates

            const dx = x - px;
            const dy = y - py;
            const dist = Math.sqrt(dx * dx + dy * dy);

            const weight = gaussian(dx, dy, CONFIG.particleRenderRadius);
            sumWeights += weight;
            weightedDx += dx * weight;
            weightedDy += dy * weight;
          }

          // Normalize and apply magnifying effect
          if (sumWeights > 0.1) {
            // Calculate displacement (magnifying effect)
            const nx = weightedDx / sumWeights;
            const ny = weightedDy / sumWeights;

            // Magnifying effect: displace pixels away from center
            const strength = Math.pow(sumWeights, 0.5);
            const displacementX = nx * strength * 0.5;
            const displacementY = ny * strength * 0.5;

            // R channel = X displacement, G channel = Y displacement
            data[idx] = 128 + displacementX; // R
            data[idx + 1] = 128 + displacementY; // G
            data[idx + 2] = 0; // B (unused)
            data[idx + 3] = 255; // Alpha
          } else {
            // No displacement outside particle area
            data[idx] = 128;
            data[idx + 1] = 128;
            data[idx + 2] = 0;
            data[idx + 3] = 255;
          }
        }
      }

      ctx.putImageData(imageData, 0, 0);

      // Update SVG filter
      const dataUrl = displacementCanvas.toDataURL();
      feImage.setAttributeNS('http://www.w3.org/1999/xlink', 'href', dataUrl);
    };
    const handleMouseDown = (e: MouseEvent) => {
      if (!particlesRef.current) return;
      const particles = particlesRef.current;
      const mouseX = e.clientX;
      const mouseY = e.clientY;
      const threshold = CONFIG.particleRenderRadius;

      let closestDist = Infinity;
      let closestIndex: number | undefined = undefined;

      particles.location.forEach((pos, i) => {
        const dx = pos[0] - mouseX;
        const dy = pos[1] - mouseY;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < threshold && dist < closestDist) {
          closestDist = dist;
          closestIndex = i;
        }
      });

      if (closestIndex !== undefined) {
        dragStateRef.current.particleIndex = closestIndex;
        dragStateRef.current.offset = [
          particles.location[closestIndex][0] - mouseX,
          particles.location[closestIndex][1] - mouseY,
        ];
        dragStateRef.current.target = [...particles.location[closestIndex]];
        dragStateRef.current.active = true;
      }
    };

    const handleMouseMove = (e: MouseEvent) => {
      if (!dragStateRef.current.active) return;
      const mouseX = e.clientX;
      const mouseY = e.clientY;
      const targetX = mouseX + dragStateRef.current.offset[0];
      const targetY = mouseY + dragStateRef.current.offset[1];
      dragStateRef.current.target = [targetX, targetY];
    };

    const handleMouseUp = () => {
      dragStateRef.current.active = false;
    };

    canvas.addEventListener('mousedown', handleMouseDown);
    window.addEventListener('mousemove', handleMouseMove);
    window.addEventListener('mouseup', handleMouseUp);

    // Resize handler
    const handleResize = () => {
      const width = window.innerWidth;
      const height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
      renderer.setSize(width, height);
      material.uniforms.resolution.value.set(width, height);
      captureAndProcess();
    };
    window.addEventListener('resize', handleResize);

    // Initial capture
    const preloadImages = () => {
      return new Promise<void>((resolve) => {
        const images = document.querySelectorAll('img');
        let loadedCount = 0;

        if (images.length === 0) {
          resolve();
          return;
        }

        images.forEach((img) => {
          if (img.complete) {
            loadedCount++;
          } else {
            img.onload = () => {
              loadedCount++;
              if (loadedCount === images.length) resolve();
            };
            img.onerror = () => {
              loadedCount++;
              if (loadedCount === images.length) resolve();
            };
          }
        });

        if (loadedCount === images.length) resolve();
      });
    };

    // Animation loop
    let step = 0;
    const animationLoop = () => {
      oneStep();

      if (particlesRef.current) {
        material.uniforms.particles.value = particlesRef.current.location.map(
          (e) => new THREE.Vector2(e[0], window.innerHeight - e[1])
        );
      }

      if (step % CONFIG.captureInterval === 0) {
        captureAndProcess();
      } else if (texture) {
        render(texture);
      }

      step++;
      animationRef.current = requestAnimationFrame(animationLoop);
    };

    // Start animation
    preloadImages().then(() => {
      captureAndProcess();
      animationLoop();
    });

    // Cleanup
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
      canvas.removeEventListener('mousedown', handleMouseDown);
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('mouseup', handleMouseUp);
      window.removeEventListener('resize', handleResize);
      container.removeChild(liquidCanvas);
      renderer.dispose();
      material.dispose();
    };
  }, []);

  return (
    <div
      ref={containerRef}
      style={{
        position: 'fixed',
        top: 0,
        left: 0,
        width: '100vw',
        height: '100vh',
        zIndex: 9999,
        pointerEvents: 'none',
      }}
    >
      <canvas
        ref={canvasRef}
        style={{
          position: 'fixed',
          top: 0,
          left: 0,
          width: '100%',
          height: '100%',
          zIndex: 10000,
          pointerEvents: 'auto',
        }}
      />
    </div>
  );
}
